syntax = "proto3";

import "google/protobuf/timestamp.proto";

package modal.sandbox_router;

service SandboxRouterService {
  // Execute a command in the sandbox.
  rpc SandboxExecStart(SandboxExecStartRequest) returns (SandboxExecStartResponse);
  // Get a stream of output from the stdout or stderr stream of an exec'd command.
  rpc SandboxExecStdioRead(SandboxExecStdioReadRequest) returns (stream SandboxExecStdioReadResponse);
  // Write to the stdin stream of an exec'd command.
  rpc SandboxExecStdinWrite(stream SandboxExecStdinWriteRequest) returns (SandboxExecStdinWriteResponse);
  // Wait for an exec'd command to exit and return the exit code.
  rpc SandboxExecWait(SandboxExecWaitRequest) returns (SandboxExecWaitResponse);
}

enum SandboxStdioFileDescriptor {
  // Read from stdout.
  SANDBOX_STDIO_FILE_DESCRIPTOR_STDOUT = 0;
  // Read from stderr.
  SANDBOX_STDIO_FILE_DESCRIPTOR_STDERR = 1;
}

enum SandboxExecStdoutConfig {
  // The output will be discarded.
  SANDBOX_EXEC_STDOUT_CONFIG_DEVNULL = 0;
  // The output will be streamed to the client.
  SANDBOX_EXEC_STDOUT_CONFIG_PIPE = 1;
}

enum SandboxExecStderrConfig {
  // The output will be discarded.
  EXEC_STDERR_CONFIG_DEVNULL = 0;
  // The output will be streamed to the client.
  EXEC_STDERR_CONFIG_PIPE = 1;
  // A special value that can be used to indicate that the stderr stream should
  // be merged with the stdout stream.
  EXEC_STDERR_CONFIG_STDOUT = 2;
}

message SandboxExecStartRequest {
  // Execution ID. This ID will be used to identify the execution for other
  // requests and ensure exec commands are idempotent.
  //
  // TODO(saltzm): Could instead have a separate idempotency key from the exec_id
  // like present day, and have the server generate the exec_id and return it in
  // the ExecStartResponse.
  string exec_id = 1;
  // Command arguments to execute.
  repeated string command_args= 2;
  // Configures how the stdout of the command will be handled.
  SandboxExecStdoutConfig stdout_config = 3;
  // Configures how the stderr of the command will be handled.
  SandboxExecStderrConfig stderr_config = 4;
  // Deadline for the exec'd command to exit. If the command does not exit before
  // the deadline, the command will be killed. This is NOT the deadline for the
  // ExecStartRequest RPC to complete.
  google.protobuf.Timestamp deadline = 5;
  // Working directory for the command.
  optional string workdir = 6;
  // Secret IDs to mount into the sandbox.
  repeated string secret_ids = 7;
  // TODO(saltzm): Add remaining fields (pty_info, runtime_debug)
}

message SandboxExecStartResponse { }

message SandboxExecStdioReadRequest {
  string exec_id = 1;
  // The offset to start reading from. This is used to resume reading from the
  // last read position if the connection is closed and reopened.
  uint64 offset = 2;
  // Which file descriptor to read from.
  SandboxStdioFileDescriptor file_descriptor = 3;
}

message SandboxExecStdioReadResponse {
  bytes data = 1;
}

message SandboxExecStdinWriteRequest {
  string exec_id = 1;
  // The offset to start writing to. This is used to resume writing from the
  // last write position if the connection is closed and reopened.
  uint64 offset = 2;
  bytes data = 3;
}

message SandboxExecStdinWriteResponse { }

message SandboxExecWaitRequest {
  string exec_id = 1;
}

message SandboxExecWaitResponse {
  oneof exit_status {
    int32 code = 1;
    int32 signal = 2;
  }
}
